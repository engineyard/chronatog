h2. Disclaimer!

This document describes Chronatog as a web cron service.  The descriptions presented are accurate with one important exception: *ACTUAL CRON IS NOT YET IMPLEMENTED*.  This means you can register as many callbacks as you want, see them, delete them, etc., but they will never actually run.  Chronatog is currently entirely missing its underlying actual cron component.

h1. Chronatog

Chronatog is:

# A simple service providing basic web cron. (lib/server)
# A Ruby client implementation for the chronatog.engineyard.com web service. (lib/client, chronatog-client.gemspec)
# An example service demonstrating how to integrate with the Engine Yard services API. (lib/ey_integration)
# A gem for use by the internal Engine Yard services API implementation, for testing. (chronatog.gemspec)
# This document designed for helping partners get started with the Engine Yard services API. (README.textile)

!https://github.com/engineyard/chronatog/raw/master/images/chronatog.jpg!

h2. Getting Started: Deploying your own Chronatog

h3. Become a partner

First you need a partner account with Engine Yard.  Once you have one, you can login at "https://services.engineyard.com":https://services.engineyard.com.

h3. Save your credentials

In Chronatog, credentials are stored in config/ey_partner_credentials.yml.

Example to generate this file in script/console:

bc.. $ script/console
> Chronatog::EyIntegration.save_creds('ff4d04dbea52c605', 'e301bcb647fc4e9def6dfb416722c583cf3058bc1b516ebb2ac99bccf7ff5c5ea22c112cd75afd28')
=> #<struct Chronatog::EyIntegration::Credentials auth_id="ff4d04dbea52c605", auth_key="e301bcb647fc4e9def6dfb416722c583cf3058bc1b516ebb2ac99bccf7ff5c5ea22c112cd75afd28">

h3. Test your connection

To test your connection to services.engineyard.com, you can make a GET request to the registration url.  This returns a listing of currently registered services.

Example:

bc.. $ script/console
> Chronatog::EyIntegration.connection.list_services(registration_url)
=> []

p. Behind the scenes, Chronatog is calling out to @EY::ServicesAPI@.

@list_services@ is a method on @EY::ServicesAPI::Connection@.

h3. Register your services

For the remainder of the setup steps, you need to have Chronatog running somewhere with a publicly accessible url.

To register your service, you make a POST request to the registration url, passing a JSON body describing your service.  Included in that description are callback URLS, so, in order to generate them, Chronatog needs to know its public-facing url.

Example:

bc.. $ script/console
> registration_url = http://services.engineyard.com/api/1/partners/96/services
> chronatog_url = "https://chronatog.engineyard.com"
> registered_service = Chronatog::EyIntegration.register_service(registration_url, chronatog_url)
=> #<struct Chronatog::EyIntegration::Service url="http://services.engineyard.com/api/1/partners/96/services/97">

p. Behind the scene, Chronatog is calling @register_service@ on a @EY::ServicesAPI::Connection@.  The first parameter is the @registration_url@. The second parameter is a hash describing the service being registered.

In the case of this example, it looks something like:

bc.. {
  :service_accounts_url     => "https://chronatog.engineyard.com/eyintegration/api/1/customers", 
  :terms_and_conditions_url => "https://chronatog.engineyard.com/terms", 
  :description              => "Web cron as a service.",
  :vars                     => ["service_url", "auth_username", "auth_password"],
  :label                    => "chronatog",
  :name                     => "Chronatog",
  :home_url                 => "https://chronatog.engineyard.com/"
} 

h3. Viewing your service on cloud.engineyard.com

If your service registration succeeded, you can see its information displayed when you visit @https://services.engineyard.com@.  From there, you can enable testing of your service with any Engine Yard Cloud account you have access to.  

!https://github.com/engineyard/chronatog/raw/master/images/enable_for_testing.png!

If you don't have any Engine Yard Cloud accounts, you can create a free trial account at: @https://cloud.engineyard.com/@.

Once enabled for testing, you can see your service available if you navigate to "Services" in the menu bar from @https://cloud.engineyard.com@.

!https://github.com/engineyard/chronatog/raw/master/images/enable_on_account.png!

h3. Verifying requests from Engine Yard

By using the @EY::ApiHMAC::ApiAuth::LookupServer@ middleware in the API controller, Chronatog verifies that each request to its API is correctly signed by the requester.  The block passed to the middleware is expected to return the @auth_key@ correspondent to the @auth_id@ given.  It is then up to @EY::ApiHMAC@ to calculate a signature and verify that it matches the one in the request (@env@).

bc.. use EY::ApiHMAC::ApiAuth::LookupServer do |env, auth_id|
  EyIntegration.api_creds && (EyIntegration.api_creds.auth_id == auth_id) && EyIntegration.api_creds.auth_key
end

h3. Enabling your service

When you click 'enable', Engine Yard makes a call to your @service_accounts_url@ to create a service account.  In the case of Chronatog, this callback is handled by creating a customer record.

The request looks something like this:

bc.. POST https://chronatog.engineyard.com/eyintegration/api/1/customers
{
  "messages_url": "http://services.engineyard.com/api/1/partners/80/services/81/service_accounts/85/messages",
  "url": "http://services.engineyard.com/api/1/partners/80/services/81/service_accounts/85",
  "name": "some-account", 
  "invoices_url": "http://services.engineyard.com/api/1/partners/80/services/81/service_accounts/85/invoices"
}

p. Chronatog handles the callback with the implementation defined in the API controller:

bc.. request_body = request.body.read
service_account = EY::ServicesAPI::ServiceAccountCreation.from_request(request_body)
create_params = {
  :name         => service_account.name,
  :api_url      => service_account.url,
  :messages_url => service_account.messages_url,
  :invoices_url => service_account.invoices_url
}
customer = Chronatog::Server::Customer.create!(create_params)

p. As part of handling the callback, a @Customer@ is created:

bc.. #<Chronatog::Server::Customer id: 1, service_id: nil, name: "some-account", created_at: "2012-04-20 10:25:27", updated_at: "2012-04-20 10:25:27", api_url: "http://services.engineyard.com/api/1/partners/2/ser...", messages_url: "http://services.engineyard.com/api/1/partners/2/ser...", invoices_url: "http://services.engineyard.com/api/1/partners/2/ser...", plan_type: "freemium", last_billed_at: nil>

p. Chronatog returns a JSON response that tells Engine Yard some information about the customer.

The code for generating that response:

bc.. response_params = {
  :configuration_required   => false,
  :configuration_url        => "#{sso_base_url}/customers/#{customer.id}",
  :provisioned_services_url => "#{api_base_url}/customers/#{customer.id}/schedulers",
  :url                      => "#{api_base_url}/customers/#{customer.id}",
  :message                  => EY::ServicesAPI::Message.new(:message_type => "status", 
                                                            :subject      => "Thanks for signing up for Chronatog!")
}
response = EY::ServicesAPI::ServiceAccountResponse.new(response_params)
content_type :json
headers 'Location' => response.url
response.to_hash.to_json

p. Notice @EY::ServicesAPI::Message@ in the code above.  The subject text now appears in the context of the Chronatog service on @https://cloud.engineyard.com@.

What the generated response looks like:

bc.. {
  "service_account": {
    "configuration_url": "https://chronatog.engineyard.com/eyintegration/sso/customers/1", 
    "provisioned_services_url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers",
    "url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1",
    "configuration_required": false
  }, 
  "message": {
    "body": null,
    "subject": "Thanks for signing up for Chronatog!", 
    "message_type": "status"
  }
}

h3. Visiting Chronatog over SSO

With the service enabled, a "Visit" link appears.  Following this link redirects to the @configuration_url@ provided in the response to service enablement.

The configuration url provided by Chronatog in this example was:

bc.. https://chronatog.engineyard.com/eyintegration/sso/customers/1

p. When Engine Yard signs the url, it provides additional parameters, such that it looks like this:

bc.. https://chronatog.engineyard.com/eyintegration/sso/customers/1?access_level=owner&ey_return_to_url=https%3A%2F%2Fcloud.engineyard.com%2Fdashboard&ey_user_id=57&ey_user_name=Person+Name&timestamp=2012-04-20T10%3A25%3A28-07%3A00&signature=AuthHMAC+123edf%3A4W0PcO78by%2B79lQbZYECTne1HgQ%3D

p. Chronatog verifies the SSO request with a before filter that looks like this:

bc.. before do
  if session["ey_user_name"]
    #already logged in
  elsif EY::ApiHMAC::SSO.authenticated?(request.url,
                                        Chronatog::EyIntegration.api_creds.auth_id,
                                        Chronatog::EyIntegration.api_creds.auth_key)
  then
    session["ey_return_to_url"] = params[:ey_return_to_url]
    session["ey_user_name"] = params[:ey_user_name]
  else
    halt 401, "SSO authentication failed. <a href='#{params[:ey_return_to_url]}'>Go back</a>."
  end
end

h3. Provisioning a Chronatog scheduler

With the service enabled in Engine Yard Cloud, it appears available for provisioning when you drill-down in the UI to viewing a single environment within the context of a single application.

!https://github.com/engineyard/chronatog/raw/master/images/provision.png!

Clicking "Provision" causes Engine Yard to call to your @provisioned_services_url@ to create a provisioned service.  In the case of Chronatog, this callback is handled by creating a scheduler.

The request looks something like this:

bc.. POST https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers
{
  "messages_url": "http://services.engineyard.com/api/1/partners/99/services/100/service_accounts/104/provisioned_service/109/messages",
  "environment": {
    "framework_env": "production",
    "aws_region": "us-east-1",
    "id": 107,
    "name": "myenv"
  },
  "url": "http://services.engineyard.com/api/1/service_accounts/104/provisioned_service/109",
  "app": {
    "id": 106,
    "name": "myapp"
  }
}

p. Chronatog handles the callback with the implementation defined in the API controller:

bc.. request_body = request.body.read
provisioned_service = EY::ServicesAPI::ProvisionedServiceCreation.from_request(request_body)

customer = Chronatog::Server::Customer.find(customer_id)
create_params = {
  :api_url => provisioned_service.url,
  :environment_name => provisioned_service.environment.name,
  :app_name => provisioned_service.app.name,
  :messages_url => provisioned_service.messages_url,
  :usage_calls => 0
}
scheduler = customer.schedulers.create!(create_params)

p. As part of handling the callback, a @Customer@ is created:

bc.. #<Chronatog::Server::Scheduler id: 1, customer_id: 1, auth_username: "Ude4733db71efc4", auth_password: "P8c546e16ecaaac6a7c209d98da", created_at: "2012-04-20 10:25:28", updated_at: "2012-04-20 10:25:28", api_url: "http://services.engineyard.com/api/1/service_accoun...", environment_name: "myenv", app_name: "myapp", messages_url: "http://services.engineyard.com/api/1/partners/112/s...", decomissioned_at: nil, usage_calls: 0>

p. Chronatog returns a JSON response that tells Engine Yard some information about the created scheduler.

The code for generating the response:

bc.. response_params = {
  :configuration_required => false,
  :vars     => {
    "service_url"   => "#{true_base_url}/chronatogapi/1/jobs",
    "auth_username" => scheduler.auth_username,
    "auth_password" => scheduler.auth_password,
  },
  :url      => "#{api_base_url}/customers/#{customer.id}/schedulers/#{scheduler.id}",
  :message  => EY::ServicesAPI::Message.new(:message_type => "status", 
                                            :subject      => "Your scheduler has been created and is ready for use!")
}
response = EY::ServicesAPI::ProvisionedServiceResponse.new(response_params)
content_type :json
headers 'Location' => response.url
response.to_hash.to_json

p. Notice @EY::ServicesAPI::Message@ in the code above.  The subject text now appears in the context of the relevant application and environment on @https://cloud.engineyard.com@.

What the response JSON looks like:

bc.. {
  "provisioned_service": {
    "configuration_url": null, 
    "vars": {
      "service_url": "https://chronatog.engineyard.com/chronatogapi/1/jobs", 
      "auth_username": "U8d44e37521b1c6",
      "auth_password": "P053d2e6ec2acee27a7bd3465f6"
    },
    "url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers/1",
    "configuration_required": false
  }, 
  "message": {
    "body": null,
    "subject": "Your scheduler has been created and is ready for use!", 
    "message_type": "status"
  }
}

h3. Updating API keys

When the scheduler was provisioned we saved the @provisioned_service.url@ into the scheduler @api_url@.  We can use this URL to update Engine Yard whenever we change vars.

For example, when we call @reset_auth!@ on a scheduler:

bc.. def reset_auth!
  self.auth_username = "U"+SecureRandom.hex(7)
  self.auth_password = "P"+SecureRandom.hex(13)
  EY::ServicesAPI.connection.update_provisioned_service(self.api_url, {
    "vars" => { "auth_username" => self.auth_username,
                "auth_password" => self.auth_password }})
  save!
end

p. We will cause the following request:

bc.. PUT http://services.engineyard.com/api/1/service_accounts/104/provisioned_service/109
{
  "provisioned_service": {
    "vars": {
      "auth_username": "U63cc7b0ed4545e",
      "auth_password": "P28265a5b541bd7d6db16423803"
    }
  }
}

h3. Using the provisioned Chronatog service in your application

The Chronatog service has been enabled and provisioned. Values for @service_url@, @auth_username@, and @auth_password@ have been generated and sent back to Engine Yard.  Now it's time to make use of the service in your  application.  Just check-in few changes to your application and deploy!

The public client gem for the Chronatog API is called @chronatog-client@. Add it to your Gemfile like this:

bc.. gem 'chronatog-client', :require => 'chronatog/client'

p. To initialize the Chronatog client with the provisioned configs, you also need another gem, @ey_config@:

bc.. gem 'ey_config'

p. With these two gems installed, setting up Chronatog can be done like so:

bc.. @client = Chronatog::Client.setup!(EY::Config.get(:chronatog, 'service_url'), 
                                   EY::Config.get(:chronatog, 'auth_username'), 
                                   EY::Config.get(:chronatog, 'auth_password'))

p. @EY::Config@ works by reading the contents of @config/ey_services_config_local.yml@ or @config/ey_services_config_deploy.yml@. In order to develop with a fake version of the Chronatog API locally, you can create @config/ey_services_config_local.yml@ with the contents:

bc.. ---
chronatog:
  service_url: in-memory
  auth_username: 123-ignored
  auth_password: 456-also-ignored



p. When you deploy, Engine Yard creates @config/ey_services_config_deploy.yml@.  It might look something like this:

bc.. ---
chronatog:
  service_url: https://chronatog.engineyard.com/chronatogapi/1/jobs
  auth_username: U2a4276f37ff412
  auth_password: P12fb35e4e4154e7af8041a3ea0



p. The existence of @config/ey_services_config_deploy.yml@ will override all settings in @config/ey_services_config_local.yml@.

h3. Disabling the Chronatog service

As amazing as our Chronatog web service is, we still need to support users deciding they don't need it anymore and disabling it.

When the service is disabled, Engine Yard makes a DELETE call to the @url@ provided when the service account was first created.

The request looks something like this:

bc.. DELETE https://chronatog.engineyard.com/eyintegration/api/1/customers/1

p. Chronatog handles that request with the implementation defined in the API controller:

bc.. customer = Chronatog::Server::Customer.find(customer_id)
customer.bill!
customer.destroy
content_type :json
{}.to_json

p. Notice the call to @customer.bill!@. This causes Chronatog to send a final bill for services before destroying the customer. The request sent looks something like this:

bc.. POST http://services.engineyard.com/api/1/partners/80/services/81/service_accounts/85/invoices
{
  "invoice": {
    "line_item_description": "For service from 2012/04/19 to 2012/04/20 includes 1 schedulers and 5 jobs run.",
    "total_amount_cents": 27
  }
}

h3. Billing

Hopefully, normally, customers will use the Chronatog service for a long period of time before canceling. So, we need a way to charge them periodically as well.

The mechanism for this is currently a manual process run once a month via script/console.

Simply run:

bc.. $ script/console
> Chronatog::Server::Customer.all.each(&:bill!)

p. This, of course, calls @bill!@ on all customers, which calculates charges and sends an invoice to the @invoices_url@ for each customer.

The implementation as defined in @Chronatog::EyIntegration::CustomerExtensions@ calculates the total amount owed based on the last time billing was run for each customer (@last_billed_at@ or @created_at@).  It then sends an invoice to the @invoices_url@ and sets the @last_billed_at@ to now.

bc.. def bill!
  #don't bill free customers
  return if plan_type == "freemium"

  self.last_billed_at ||= created_at
  billing_at = Time.now
  #having the awesome service active costs $0.02 per day
  total_price = 2 * (billing_at.to_i - last_billed_at.to_i) / 60 / 60 / 24

  total_jobs_ran = 0
  schedulers.each do |schedule|
    #add $0.05 for every time we called a job
    usage_price = 5 * schedule.usage_calls
    total_jobs_ran += schedule.usage_calls
    schedule.usage_calls = 0
    schedule.save
    total_price += usage_price
  end
  if total_price > 0
    line_item_description = [
      "For service from #{last_billed_at.strftime('%Y/%m/%d')}",
      "to #{billing_at.strftime('%Y/%m/%d')}",
      "includes #{schedulers.size} schedulers", 
      "and #{total_jobs_ran} jobs run.",
    ].join(" ")

    invoice = EY::ServicesAPI::Invoice.new(:total_amount_cents => total_price,
                                           :line_item_description => line_item_description)
    Chronatog::EyIntegration.connection.send_invoice(self.invoices_url, invoice)

    self.last_billed_at = billing_at
    save!
  end
end

h3. More

TODO: Provisioned service SSO.

TODO: Using those API keys works. Chronatog automatically updates the status to tell the user they are now using the service. Tell them how many jobs are scheduled.

TODO: Using the API to create more than 10 jobs on the free plan and Chronatog sends a notification prompting you to upgrade.

TODO: Examining the monthly billing job Chronatog created in itself and forcing it to run.

