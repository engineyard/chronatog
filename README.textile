h2. Disclaimer!

The following document describes Chronatog as a web cron service.  The descriptions presented are accurate with one important exception: *ACTUAL CRON IS NOT YET IMPLEMENTED*.  This means you can register as many callbacks as you want, see them, delete them etc... but they will never actually run.  Chronatog is currently entirely missing it's underlying actual cron component.

h1. Chronatog

Chronatog is:

# A simple service providing basic web cron. (lib/server)
# A ruby client implementation for the chronatog.engineyard.com web service. (lib/client, chronatog-client.gemspec)
# An example service demonstrating how to integrate with the EngineYard services API. (lib/ey_integration)
# A gem for use by the internal EngineYard services API implementation, for testing. (chronatog.gemspec)
# This document designed for helping partners get started with the EY services API. (README.textile)

!https://github.com/engineyard/chronatog/raw/master/images/chronatog.jpg!

h2. Getting Started: Deploying your own Chronatog

h3. Become a Partner

First you need a partner account with EngineYard.  Once you have one, you should be able to login at "https://services.engineyard.com":https://services.engineyard.com.

h3. Save your credentials

In Chronatog, credentials are stored in config/ey_partner_credentials.yml.

Example to generate this file in script/console:

bc.. $ script/console
> Chronatog::EyIntegration.save_creds('ff4d04dbea52c605', 'e301bcb647fc4e9def6dfb416722c583cf3058bc1b516ebb2ac99bccf7ff5c5ea22c112cd75afd28')
=> #<struct Chronatog::EyIntegration::Credentials auth_id="ff4d04dbea52c605", auth_key="e301bcb647fc4e9def6dfb416722c583cf3058bc1b516ebb2ac99bccf7ff5c5ea22c112cd75afd28">

h3. Test your connection

To test your connection to services.engineyard.com, you can make a GET request to the registration url.  This returns a listing of currently registered services.

Example:

bc.. $ script/console
> Chronatog::EyIntegration.connection.list_services(registration_url)
=> []

p. Behind the scenes, Chronatog is calling out to @EY::ServicesAPI@.

@list_services@ is a method on @EY::ServicesAPI::Connection@.

h3. Register your services

For the remainder of the setup steps, you will need to have Chronatog running somewhere with a publicly accessible url.

To register your service, you make a POST request to the registration url, passing a JSON body describing your service.  Included in that description are callback URLS, so in order to generate them Chronatog needs to know it's public-facing url.

Example:

bc.. $ script/console
> registration_url = "http://services.engineyard.com/api/1/partners/10/services"
> chronatog_url = "https://chronatog.engineyard.com"
> registered_service = Chronatog::EyIntegration.register_service(registration_url, chronatog_url)
=> #<struct Chronatog::EyIntegration::Service url="http://services.engineyard.com/api/1/partners/10/services/9">

p. Behind the scene, Chronatog is calling @register_service@ on a @EY::ServicesAPI::Connection@.  The first parameter is the @registration_url@. The second parameter is a hash describing the service being registered.

In the case of this example it looks something like:

bc.. {
  :vars                     => ["CHRONOS_AUTH_USERNAME", "CHRONOS_AUTH_PASSWORD", "CHRONOS_SERVICE_URL"],
  :home_url                 => "https://chronatog.engineyard.com/", 
  :service_accounts_url     => "https://chronatog.engineyard.com/eyintegration/api/1/customers", 
  :terms_and_conditions_url => "https://chronatog.engineyard.com/terms", 
  :name                     => "Chronatog", 
  :description              => "Web cron as a service."
} 

h3. Viewing your service on cloud.engineyard.com

If your service registration succeeded, you should see it's information displayed when you visit @https://services.engineyard.com@.  From there you can enable testing of your service with any cloud account you have access to.  

!https://github.com/engineyard/chronatog/raw/master/images/enable_for_testing.png!

If you don't have any cloud accounts, you can create a free trial account at: @https://cloud.engineyard.com/@.

Once enabled for testing, you should see your service available if you navigate to "Services" in the menu bar from @https://cloud.engineyard.com@.

!https://github.com/engineyard/chronatog/raw/master/images/enable_on_account.png!

h3. Verifying requests from Engine Yard

By using the @EY::ApiHMAC::ApiAuth::LookupServer@ middleware in the API controller, Chronatog verifies that each request to it's API is correctly signed by the requester.  The block passed to the middleware is expected to return the @auth_key@ correspondent to the @auth_id@ given.  It is then up to @EY::ApiHMAC@ to calculate a signature and verify that it matches the one in the request (@env@).

bc.. use EY::ApiHMAC::ApiAuth::LookupServer do |env, auth_id|
  EyIntegration.api_creds && (EyIntegration.api_creds.auth_id == auth_id) && EyIntegration.api_creds.auth_key
end

h3. Enabling your service

When you click 'enable', EngineYard will make a call to your @service_accounts_url@ to create a service account.  In the case of Chronatog, this callback is handled by creating a customer record.

The request will look something like this:

bc.. POST "https://chronatog.engineyard.com/eyintegration/api/1/customers"
{
  "name": "some-account", 
  "invoices_url": "http://services.engineyard.com/api/1/partners/7/services/7/service_accounts/7/invoices", 
  "url": "http://services.engineyard.com/api/1/partners/7/services/7/service_accounts/7", 
  "messages_url": "http://services.engineyard.com/api/1/partners/7/services/7/service_accounts/7/messages"
}

p. Chronatog will handle the callback with the implementation defined in the API controller:

bc.. request_body = request.body.read
service_account = EY::ServicesAPI::ServiceAccountCreation.from_request(request_body)
create_params = {
  :name         => service_account.name,
  :api_url      => service_account.url,
  :messages_url => service_account.messages_url,
  :invoices_url => service_account.invoices_url
}
customer = Chronatog::Server::Customer.create!(create_params)

p. As part of handling the callback, a @Customer@ will be created:

bc.. #<Chronatog::Server::Customer id: 1, service_id: nil, name: "some-account", created_at: "2011-10-07 15:54:41", updated_at: "2011-10-07 15:54:41", api_url: "http://services.engineyard.com/api/1/partners/0/ser...", messages_url: "http://services.engineyard.com/api/1/partners/0/ser...", invoices_url: "http://services.engineyard.com/api/1/partners/0/ser...", plan_type: "freemium", last_billed_at: nil>

p. Chronatog returns a JSON response that tells EngineYard some information about the customer.

The code for generating that response:

bc.. response_params = {
  :configuration_required   => false,
  :configuration_url        => "#{sso_base_url}/customers/#{customer.id}",
  :provisioned_services_url => "#{api_base_url}/customers/#{customer.id}/schedulers",
  :url                      => "#{api_base_url}/customers/#{customer.id}",
  :message                  => EY::ServicesAPI::Message.new(:message_type => "status", 
                                                            :subject      => "Thanks for signing up for Chronatog!")
}
response = EY::ServicesAPI::ServiceAccountResponse.new(response_params)
content_type :json
headers 'Location' => response.url
response.to_hash.to_json

p. Notice @EY::ServicesAPI::Message@ in the code above.  The subject text should now appear in the context of the Chronatog service on @https://cloud.engineyard.com@.

What the generated response looks like:

bc.. {
  "service_account": {
    "url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1", 
    "provisioned_services_url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers", 
    "configuration_url": "https://chronatog.engineyard.com/eyintegration/sso/customers/1", 
    "configuration_required": false
  }, 
  "message": {
    "message_type": "status", 
    "body": null, 
    "subject": "Thanks for signing up for Chronatog!"
  }
}

h3. Visiting Chronatog over SSO

With the service enabled, a "Visit" link should appear.  Following this link will redirect to the @configuration_url@ provided in the response to service enablement.

The configuration url provided by Chronatog in this example was:

bc.. "https://chronatog.engineyard.com/eyintegration/sso/customers/1"

p. When EY signs the url it provides additional parameters, such that it looks like this:

bc.. "https://chronatog.engineyard.com/eyintegration/sso/customers/1?access_level=owner&ey_return_to_url=https%3A%2F%2Fcloud.engineyard.com%2Fdashboard&ey_user_id=123&ey_user_name=Person+Name&timestamp=2011-10-07T15%3A54%3A42-07%3A00&signature=AuthHMAC+123edf%3Apk6s7g6lADF1YSenJiy8pXJgSgw%3D"

p. Chronatog will verify the SSO request with a before filter that looks like this:

bc.. before do
  if session["ey_user_name"]
    #already logged in
  elsif EY::ApiHMAC::SSO.authenticated?(request.url,
                                        Chronatog::EyIntegration.api_creds.auth_id,
                                        Chronatog::EyIntegration.api_creds.auth_key)
  then
    session["ey_return_to_url"] = params[:ey_return_to_url]
    session["ey_user_name"] = params[:ey_user_name]
  else
    halt 401, "SSO authentication failed. <a href='#{params[:ey_return_to_url]}'>Go back</a>."
  end
end

h3. Provisioning a Chronatog Scheduler

With the service enabled in EngineYard cloud, it should appear available for provisioning when you drill-down in the UI to viewing a single environment within the context of a single application.

!https://github.com/engineyard/chronatog/raw/master/images/provision.png!

Clicking "Provision" will cause EngineYard to call to your @provisioned_services_url@ to create a provisioned service.  In the case of Chronatog, this callback is handled by creating a scheduler.

The request will look something like this:

bc.. POST "https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers"
{
  "app": {
    "name": "myapp", 
    "id": 1
  }, 
  "url": "http://services.engineyard.com/api/1/service_accounts/9/provisioned_service/1", 
  "environment": {
    "name": "myenv", 
    "framework_env": "production", 
    "id": 1
  }, 
  "messages_url": "http://services.engineyard.com/api/1/partners/12/services/11/service_accounts/9/provisioned_service/1/messages"
}

p. Chronatog will handle the callback with the implementation defined in the API controller:

bc.. request_body = request.body.read
provisioned_service = EY::ServicesAPI::ProvisionedServiceCreation.from_request(request_body)

customer = Chronatog::Server::Customer.find(customer_id)
create_params = {
  :environment_name => provisioned_service.environment.name,
  :app_name => provisioned_service.app.name,
  :messages_url => provisioned_service.messages_url
}
scheduler = customer.schedulers.create!(create_params)

p. As part of handling the callback, a @Customer@ will be created:

bc.. #<Chronatog::Server::Scheduler id: 1, customer_id: 1, auth_username: "acde0341715fb5", auth_password: "f920f21f0839804729d10a7405", created_at: "2011-10-07 15:54:42", updated_at: "2011-10-07 15:54:42", environment_name: "myenv", app_name: "myapp", messages_url: "http://services.engineyard.com/api/1/partners/11/se...", decomissioned_at: nil, last_billed_at: nil>

p. Chronatog returns a JSON response that tells EngineYard some information about the created scheduler.

The code for generating the response:

bc.. response_params = {
  :configuration_required => false,
  :vars     => {
    "CHRONOS_AUTH_USERNAME" => scheduler.auth_username,
    "CHRONOS_AUTH_PASSWORD" => scheduler.auth_password,
    "CHRONOS_SERVICE_URL"   => "#{true_base_url}/chronatogapi/1/jobs",
  },
  :url      => "#{api_base_url}/customers/#{customer.id}/schedulers/#{scheduler.id}",
  :message  => EY::ServicesAPI::Message.new(:message_type => "status", 
                                            :subject      => "Your scheduler has been created and is ready for use!")
}
response = EY::ServicesAPI::ProvisionedServiceResponse.new(response_params)
content_type :json
headers 'Location' => response.url
response.to_hash.to_json

p. Notice @EY::ServicesAPI::Message@ in the code above.  The subject text should now appear in the context of the relevant application and environment on @https://cloud.engineyard.com@.

What the response JSON looks like:

bc.. {
  "provisioned_service": {
    "vars": {
      "CHRONOS_AUTH_USERNAME": "fd12cbc03357cb", 
      "CHRONOS_SERVICE_URL": "https://chronatog.engineyard.com/chronatogapi/1/jobs", 
      "CHRONOS_AUTH_PASSWORD": "ca55f55705ac0abe9ffd97cdde"
    }, 
    "url": "https://chronatog.engineyard.com/eyintegration/api/1/customers/1/schedulers/1", 
    "configuration_url": null, 
    "configuration_required": false
  }, 
  "message": {
    "message_type": "status", 
    "body": null, 
    "subject": "Your scheduler has been created and is ready for use!"
  }
}

h3. More

TODO: disabling service makes a callback, and Chronatog responds by sending a bill.

TODO: provisioned service SSO.

TODO: using those API keys works. Chronatog automatically updates the status to tell the user they are now using the service. Tell them how many jobs are scheduled.

TODO: using the API to create more than 10 jobs on the free plan and Chronatog sends a notification prompting you to upgrade.

TODO: Examining the monthly billing job Chronatog created in itself and forcing it to run.

